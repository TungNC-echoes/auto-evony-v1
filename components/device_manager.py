"""
Device Manager for EVONY AUTO
Handles device operations, drag & drop, and device state management
"""

import tkinter as tk
from tkinter import ttk, messagebox
import subprocess
import threading
import time
from utils.adb_utils import get_memu_devices


class DeviceManager:
    """Manages device operations and state"""
    
    def __init__(self, gui_instance):
        self.gui = gui_instance
        self.devices = []
        self.dragged_devices = []
        self.dragged_device = None
        self.dragged_from_feature = None
        
        # Feature containers - m·ªói feature s·∫Ω ch·ª©a devices ƒë∆∞·ª£c k√©o v√†o
        self.feature_devices = {
            "rally": [],
            "buy_meat": [],
            "war_no_general": [],
            "attack_boss": [],
            "open_items": [],
            "advanced_rally": [],
            "advanced_war": []
        }
        
        # Device-process mapping ƒë·ªÉ track process c·ªßa t·ª´ng device
        self.device_process_mapping = {
            "rally": {},      # {device_id: process}
            "buy_meat": {},
            "war_no_general": {},
            "attack_boss": {},
            "open_items": {},
            "advanced_rally": {},
            "advanced_war": {}
        }
    
    def kill_specific_device_process(self, device_id, device_name, feature_key):
        """Kill process c·ªßa device c·ª• th·ªÉ (kh√¥ng kill to√†n b·ªô feature)"""
        def kill_process():
            try:
                self.gui.log_status(f"üîÑ ƒêang kill process cho {device_name} (ID: {device_id})...")
                
                # T√¨m v√† kill process c·ªßa device c·ª• th·ªÉ t·ª´ mapping
                if device_id in self.device_process_mapping[feature_key]:
                    process = self.device_process_mapping[feature_key][device_id]
                    
                    try:
                        if process.is_alive():
                            self.gui.log_status(f"üî™ ƒêang kill process cho {device_name}...")
                            process.terminate()
                            process.join(timeout=3.0)
                            if process.is_alive():
                                process.kill()
                                process.join(timeout=1.0)
                            
                            # Remove process t·ª´ mapping
                            del self.device_process_mapping[feature_key][device_id]
                            
                            # Remove process t·ª´ feature_status
                            if hasattr(self.gui, 'feature_status') and feature_key in self.gui.feature_status:
                                feature_processes = self.gui.feature_status[feature_key]["processes"]
                                if process in feature_processes:
                                    feature_processes.remove(process)
                            
                            self.gui.log_status(f"‚úÖ ƒê√£ kill process cho {device_name}")
                        else:
                            # Process ƒë√£ ch·∫øt, ch·ªâ c·∫ßn remove kh·ªèi mapping
                            del self.device_process_mapping[feature_key][device_id]
                            self.gui.log_status(f"‚úÖ Process cho {device_name} ƒë√£ ch·∫øt, ƒë√£ remove kh·ªèi mapping")
                            
                    except Exception as e:
                        self.gui.log_status(f"‚ö†Ô∏è L·ªói khi kill process cho {device_name}: {e}")
                        # V·∫´n remove kh·ªèi mapping n·∫øu c√≥ l·ªói
                        if device_id in self.device_process_mapping[feature_key]:
                            del self.device_process_mapping[feature_key][device_id]
                else:
                    self.gui.log_status(f"‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y process cho {device_name} trong mapping")
                
                # Ki·ªÉm tra n·∫øu feature c√≤n devices kh√°c
                remaining_devices = len(self.feature_devices[feature_key])
                if remaining_devices <= 1:  # Ch·ªâ c√≤n device n√†y ho·∫∑c kh√¥ng c√≤n device n√†o
                    # D·ª´ng feature ho√†n to√†n
                    if hasattr(self.gui, 'feature_status') and feature_key in self.gui.feature_status:
                        if self.gui.feature_status[feature_key]["running"]:
                            self.gui.feature_status[feature_key]["running"] = False
                            
                            # Kill t·∫•t c·∫£ processes c√≤n l·∫°i
                            feature_processes = self.gui.feature_status[feature_key]["processes"]
                            for process in feature_processes:
                                try:
                                    if process.is_alive():
                                        process.terminate()
                                        process.join(timeout=1.0)
                                        if process.is_alive():
                                            process.kill()
                                except:
                                    pass
                            
                            # Clear process list v√† mapping
                            feature_processes.clear()
                            self.device_process_mapping[feature_key].clear()
                            
                            # Update UI
                            try:
                                start_button = getattr(self.gui, f"{feature_key}_start_button")
                                stop_button = getattr(self.gui, f"{feature_key}_stop_button")
                                status_label = getattr(self.gui, f"{feature_key}_status_label")
                                
                                start_button.config(state=tk.NORMAL)
                                stop_button.config(state=tk.DISABLED)
                                status_label.config(text="‚è∏Ô∏è Stopped")
                            except:
                                pass
                            
                            self.gui.log_status(f"‚èπÔ∏è Feature {feature_key} ƒë√£ d·ª´ng (kh√¥ng c√≤n devices)")
                        else:
                            self.gui.log_status(f"‚úÖ ƒê√£ kill process cho {device_name} t·ª´ {feature_key}")
                    else:
                        self.gui.log_status(f"‚úÖ ƒê√£ kill process cho {device_name} t·ª´ {feature_key}")
                else:
                    # Feature v·∫´n ti·∫øp t·ª•c ch·∫°y v·ªõi devices c√≤n l·∫°i
                    self.gui.log_status(f"‚úÖ ƒê√£ kill process cho {device_name}, {feature_key} v·∫´n ch·∫°y v·ªõi {remaining_devices-1} devices")
                
            except Exception as e:
                self.gui.log_status(f"‚ùå L·ªói khi kill device process: {e}")
        
        # Ch·∫°y kill process trong thread ri√™ng ƒë·ªÉ kh√¥ng block UI
        kill_thread = threading.Thread(target=kill_process)
        kill_thread.daemon = True
        kill_thread.start()
    
    def auto_start_feature_for_device(self, device_id, device_name, feature_key):
        """T·ª± ƒë·ªông start feature cho device m·ªõi ƒë∆∞·ª£c th√™m v√†o"""
        def start_feature():
            try:
                # ƒê·ª£i m·ªôt ch√∫t ƒë·ªÉ ƒë·∫£m b·∫£o device ƒë√£ ƒë∆∞·ª£c th√™m v√†o feature
                time.sleep(1.0)
                
                # Ki·ªÉm tra xem feature c√≥ ƒëang ch·∫°y kh√¥ng
                if hasattr(self.gui, 'feature_status') and feature_key in self.gui.feature_status:
                    if self.gui.feature_status[feature_key]["running"]:
                        self.gui.log_status(f"üöÄ T·ª± ƒë·ªông start {feature_key} cho {device_name}...")
                        
                        # T·∫°o task cho device m·ªõi
                        device_info = {'device_id': device_id, 'name': device_name}
                        
                        # Map feature key to feature code
                        feature_codes = {
                            "rally": "1",
                            "buy_meat": "2", 
                            "war_no_general": "3",
                            "attack_boss": "4",
                            "open_items": "5",
                            "buy_general": "6",
                            "advanced_rally": "7",
                            "advanced_war": "8"
                        }
                        
                        feature_code = feature_codes.get(feature_key, "1")
                        
                        # T·∫°o task
                        task = {
                            'device': device_info,
                            'feature_code': feature_code,
                            'feature_name': feature_key
                        }
                        
                        # Add troops_count for attack_boss feature
                        if feature_key == "attack_boss":
                            try:
                                troops_count = int(self.gui.attack_boss_troops_var.get().strip())
                                task['troops_count'] = troops_count
                            except:
                                task['troops_count'] = 1000  # Default fallback
                        
                        # Add selected_bosses for Advanced features
                        if feature_key in ["advanced_rally", "advanced_war"]:
                            try:
                                selected_bosses = self.gui.get_selected_bosses()
                                task['selected_bosses'] = selected_bosses
                                self.gui.log_status(f"üéØ Advanced {feature_key}: S·ª≠ d·ª•ng {len(selected_bosses)} boss ƒë∆∞·ª£c ch·ªçn")
                            except Exception as e:
                                self.gui.log_status(f"‚ö†Ô∏è Kh√¥ng th·ªÉ l·∫•y selected_bosses cho {feature_key}: {e}")
                                task['selected_bosses'] = []  # Default empty list
                        
                        # Import process manager
                        from components.process_manager import run_single_task_process
                        import multiprocessing
                        
                        # T·∫°o process m·ªõi cho device n√†y (s·ª≠ d·ª•ng multiprocessing.Process)
                        process = multiprocessing.Process(
                            target=run_single_task_process,
                            args=(task, 1, 1, self.gui.log_queue)
                        )
                        
                        # Th√™m process v√†o danh s√°ch
                        self.gui.feature_status[feature_key]["processes"].append(process)
                        
                        # L∆∞u process v√†o mapping ƒë·ªÉ track theo device_id
                        self.device_process_mapping[feature_key][device_id] = process
                        
                        # Start process
                        process.start()
                        
                        self.gui.log_status(f"‚úÖ ƒê√£ t·ª± ƒë·ªông start {feature_key} cho {device_name}")
                        
            except Exception as e:
                self.gui.log_status(f"‚ùå L·ªói khi auto start feature: {e}")
        
        # Ch·∫°y auto start trong thread ri√™ng
        start_thread = threading.Thread(target=start_feature)
        start_thread.daemon = True
        start_thread.start()
    
    def refresh_devices(self):
        """Refresh danh s√°ch devices - ch·ªâ load nh·ªØng device ch∆∞a ƒë∆∞·ª£c assign"""
        try:
            self.gui.log_status("üîÑ ƒêang t·∫£i danh s√°ch devices...")
            all_devices = get_memu_devices()
            
            # L·∫•y danh s√°ch device IDs ƒë√£ ƒë∆∞·ª£c assign v√†o c√°c feature
            assigned_device_ids = set()
            for feature_devices in self.feature_devices.values():
                for device in feature_devices:
                    assigned_device_ids.add(device['device_id'])
            
            # L·ªçc ra nh·ªØng device ch∆∞a ƒë∆∞·ª£c assign
            available_devices = []
            for device in all_devices:
                if device['device_id'] not in assigned_device_ids:
                    available_devices.append(device)
            
            # Clear existing items
            for item in self.gui.device_tree.get_children():
                self.gui.device_tree.delete(item)
            
            # Add available devices to treeview with alternating colors
            for i, device in enumerate(available_devices):
                device_id = device['device_id']
                device_name = device['name']
                
                # Add to treeview
                item = self.gui.device_tree.insert("", tk.END, values=(device_name, "Ready"))
                
                # Store device info in item
                self.gui.device_tree.item(item, tags=(device_id,))
                
                # Add alternating row colors for better visual separation
                if i % 2 == 0:
                    self.gui.device_tree.tag_configure("evenrow", background="#f8f9fa")
                    self.gui.device_tree.item(item, tags=(device_id, "evenrow"))
                else:
                    self.gui.device_tree.tag_configure("oddrow", background="#ffffff")
                    self.gui.device_tree.item(item, tags=(device_id, "oddrow"))
            
            # C·∫≠p nh·∫≠t danh s√°ch devices hi·ªán t·∫°i
            self.devices = available_devices
            
            self.gui.log_status(f"‚úÖ ƒê√£ t·∫£i {len(available_devices)} devices kh·∫£ d·ª•ng (t·ªïng c·ªông {len(all_devices)} devices)")
            
        except Exception as e:
            self.gui.log_status(f"‚ùå L·ªói khi t·∫£i devices: {e}")
            messagebox.showerror("L·ªói", f"Kh√¥ng th·ªÉ t·∫£i danh s√°ch devices:\n{e}")
    
    def refresh_all_devices(self):
        """Refresh to√†n b·ªô danh s√°ch devices t·ª´ ADB"""
        try:
            self.gui.log_status("üîÑ ƒêang t·∫£i danh s√°ch devices t·ª´ ADB...")
            all_devices = get_memu_devices()
            
            # Clear existing items
            for item in self.gui.device_tree.get_children():
                self.gui.device_tree.delete(item)
            
            # Add all devices to treeview with alternating colors
            for i, device in enumerate(all_devices):
                device_id = device['device_id']
                device_name = device['name']
                
                # Add to treeview
                item = self.gui.device_tree.insert("", tk.END, values=(device_name, "Ready"))
                
                # Store device info in item
                self.gui.device_tree.item(item, tags=(device_id,))
                
                # Add alternating row colors for better visual separation
                if i % 2 == 0:
                    self.gui.device_tree.tag_configure("evenrow", background="#f8f9fa")
                    self.gui.device_tree.item(item, tags=(device_id, "evenrow"))
                else:
                    self.gui.device_tree.tag_configure("oddrow", background="#ffffff")
                    self.gui.device_tree.item(item, tags=(device_id, "oddrow"))
            
            self.devices = all_devices
            self.gui.log_status(f"‚úÖ ƒê√£ t·∫£i {len(all_devices)} devices t·ª´ ADB")
        except Exception as e:
            self.gui.log_status(f"‚ùå L·ªói khi t·∫£i devices t·ª´ ADB: {e}")
            messagebox.showerror("L·ªói", f"Kh√¥ng th·ªÉ t·∫£i danh s√°ch devices t·ª´ ADB:\n{e}")
    
    def select_all_devices(self):
        """Ch·ªçn t·∫•t c·∫£ devices (highlight)"""
        for item in self.gui.device_tree.get_children():
            self.gui.device_tree.selection_add(item)
    
    def clear_all_devices(self):
        """Clear selection"""
        self.gui.device_tree.selection_remove(self.gui.device_tree.selection())
    
    def add_device_to_feature(self, device_item, feature_key, show_log=True):
        """Th√™m device v√†o feature container - tr·∫£ v·ªÅ True n·∫øu th√†nh c√¥ng"""
        if device_item:
            # Get device info
            device_id = self.gui.device_tree.item(device_item, "tags")[0]
            device_name = self.gui.device_tree.item(device_item, "values")[0]
            
            # Check if device already in this feature
            for device in self.feature_devices[feature_key]:
                if device['device_id'] == device_id:
                    if show_log:
                        self.gui.log_status(f"‚ö†Ô∏è Device {device_name} ƒë√£ c√≥ trong {feature_key}")
                    return False
            
            # Add device to feature
            device_info = {'device_id': device_id, 'name': device_name}
            self.feature_devices[feature_key].append(device_info)
            
            # Add to feature tree with visual feedback
            feature_tree = getattr(self.gui, f"{feature_key}_tree")
            item = feature_tree.insert("", tk.END, values=(device_name, "Ready"), tags=(device_id,))
            
            # Add visual styling for the new item
            feature_tree.tag_configure("newitem", background="#d4edda", foreground="#155724")
            feature_tree.item(item, tags=(device_id, "newitem"))
            
            # Remove the highlight after a short delay
            self.gui.root.after(2000, lambda: self.remove_highlight(feature_tree, item, device_id))
            
            # Remove device from main device list
            self.gui.device_tree.delete(device_item)
            
            # Update count
            count_label = getattr(self.gui, f"{feature_key}_count_label")
            count_label.config(text=f"{len(self.feature_devices[feature_key])} devices")
            
            if show_log:
                self.gui.log_status(f"‚úÖ ƒê√£ th√™m {device_name} v√†o {feature_key}")
            
            #  AUTO START N·∫æU FEATURE ƒêANG CH·∫†Y
            if hasattr(self.gui, 'feature_status') and feature_key in self.gui.feature_status:
                if self.gui.feature_status[feature_key]["running"]:
                    self.auto_start_feature_for_device(device_id, device_name, feature_key)
            
            return True
        return False
    
    def remove_highlight(self, tree, item, device_id):
        """Remove highlight from device item after animation"""
        try:
            # Remove the "newitem" tag but keep the device_id tag
            tree.item(item, tags=(device_id,))
        except:
            pass  # Item might have been deleted
    
    def clear_feature_devices(self, feature_key):
        """Clear t·∫•t c·∫£ devices trong m·ªôt feature"""
        # Get all devices from this feature
        devices_to_restore = self.feature_devices[feature_key].copy()
        
        # Kill processes cho t·∫•t c·∫£ devices trong feature n√†y
        for device_info in devices_to_restore:
            self.kill_specific_device_process(device_info['device_id'], device_info['name'], feature_key)
        
        # Clear feature devices
        self.feature_devices[feature_key].clear()
        feature_tree = getattr(self.gui, f"{feature_key}_tree")
        for item in feature_tree.get_children():
            feature_tree.delete(item)
        
        # Restore devices to main device list
        for device_info in devices_to_restore:
            device_id = device_info['device_id']
            device_name = device_info['name']
            
            # Add back to main device tree
            item = self.gui.device_tree.insert("", tk.END, values=(device_name, "Ready"))
            self.gui.device_tree.item(item, tags=(device_id,))
        
        count_label = getattr(self.gui, f"{feature_key}_count_label")
        count_label.config(text="0 devices")
        
        self.gui.log_status(f"üóëÔ∏è ƒê√£ clear {feature_key} v√† tr·∫£ l·∫°i {len(devices_to_restore)} devices")
    
    def clear_all_features(self):
        """Clear t·∫•t c·∫£ features"""
        total_restored = 0
        for feature_key in self.feature_devices.keys():
            # Get count before clearing
            device_count = len(self.feature_devices[feature_key])
            total_restored += device_count
            
            # Clear feature devices with kill processes
            devices_to_restore = self.feature_devices[feature_key].copy()
            
            # Kill processes cho t·∫•t c·∫£ devices trong feature n√†y
            for device_info in devices_to_restore:
                self.kill_specific_device_process(device_info['device_id'], device_info['name'], feature_key)
            
            self.feature_devices[feature_key].clear()
            feature_tree = getattr(self.gui, f"{feature_key}_tree")
            for item in feature_tree.get_children():
                feature_tree.delete(item)
            
            # Restore devices to main device list
            for device_info in devices_to_restore:
                device_id = device_info['device_id']
                device_name = device_info['name']
                
                # Add back to main device tree
                item = self.gui.device_tree.insert("", tk.END, values=(device_name, "Ready"))
                self.gui.device_tree.item(item, tags=(device_id,))
            
            # Update count
            count_label = getattr(self.gui, f"{feature_key}_count_label")
            count_label.config(text="0 devices")
        
        self.gui.log_status(f"üóëÔ∏è ƒê√£ clear t·∫•t c·∫£ features v√† tr·∫£ l·∫°i {total_restored} devices")
    
    def remove_device_from_feature(self, device_item, feature_key):
        """X√≥a device kh·ªèi feature v√† tr·∫£ v·ªÅ danh s√°ch g·ªëc - CH·ªà KILL PROCESS C·ª¶A DEVICE C·ª§ TH·ªÇ"""
        if device_item:
            # Get device info
            feature_tree = getattr(self.gui, f"{feature_key}_tree")
            device_id = feature_tree.item(device_item, "tags")[0]
            device_name = feature_tree.item(device_item, "values")[0]
            
            #  KILL PROCESS C·ª¶A DEVICE C·ª§ TH·ªÇ (KH√îNG KILL TO√ÄN B·ªò FEATURE)
            self.kill_specific_device_process(device_id, device_name, feature_key)
            
            # Remove from feature
            self.feature_devices[feature_key] = [
                device for device in self.feature_devices[feature_key] 
                if device['device_id'] != device_id
            ]
            
            # Remove from feature tree
            feature_tree.delete(device_item)
            
            # Add back to main device tree
            item = self.gui.device_tree.insert("", tk.END, values=(device_name, "Ready"))
            self.gui.device_tree.item(item, tags=(device_id,))
            
            # Update count
            count_label = getattr(self.gui, f"{feature_key}_count_label")
            count_label.config(text=f"{len(self.feature_devices[feature_key])} devices")
            
            self.gui.log_status(f"üîÑ ƒê√£ tr·∫£ {device_name} v·ªÅ danh s√°ch g·ªëc t·ª´ {feature_key}")
    
    def move_device_between_features(self, device_item, from_feature_key, to_feature_key):
        """üî• HOT SWAP: Di chuy·ªÉn device t·ª´ feature n√†y sang feature kh√°c"""
        if device_item:
            # Get device info
            from_feature_tree = getattr(self.gui, f"{from_feature_key}_tree")
            device_id = from_feature_tree.item(device_item, "tags")[0]
            device_name = from_feature_tree.item(device_item, "values")[0]
            
            # üî• KILL PROCESS C·ª¶A DEVICE C·ª§ TH·ªÇ T·ª™ FEATURE C≈®
            self.kill_specific_device_process(device_id, device_name, from_feature_key)
            
            # Remove from source feature
            self.feature_devices[from_feature_key] = [
                device for device in self.feature_devices[from_feature_key] 
                if device['device_id'] != device_id
            ]
            from_feature_tree.delete(device_item)
            
            # Add to target feature
            device_info = {'device_id': device_id, 'name': device_name}
            self.feature_devices[to_feature_key].append(device_info)
            
            to_feature_tree = getattr(self.gui, f"{to_feature_key}_tree")
            to_feature_tree.insert("", tk.END, values=(device_name, "Ready"), tags=(device_id,))
            
            # Update counts
            from_count_label = getattr(self.gui, f"{from_feature_key}_count_label")
            from_count_label.config(text=f"{len(self.feature_devices[from_feature_key])} devices")
            
            to_count_label = getattr(self.gui, f"{to_feature_key}_count_label")
            to_count_label.config(text=f"{len(self.feature_devices[to_feature_key])} devices")
            
            # üöÄ AUTO START FEATURE M·ªöI N·∫æU ƒêANG CH·∫†Y
            if hasattr(self.gui, 'feature_status') and to_feature_key in self.gui.feature_status:
                if self.gui.feature_status[to_feature_key]["running"]:
                    self.auto_start_feature_for_device(device_id, device_name, to_feature_key)
                    self.gui.log_status(f"üîÑ HOT SWAP: ƒê√£ chuy·ªÉn {device_name} t·ª´ {from_feature_key} sang {to_feature_key} (auto start)")
                else:
                    self.gui.log_status(f"üîÑ ƒê√£ chuy·ªÉn {device_name} t·ª´ {from_feature_key} sang {to_feature_key}")
            else:
                self.gui.log_status(f"üîÑ ƒê√£ chuy·ªÉn {device_name} t·ª´ {from_feature_key} sang {to_feature_key}")
    
    def add_all_selected_to_feature(self):
        """Th√™m t·∫•t c·∫£ devices ƒë√£ ch·ªçn v√†o feature ƒë∆∞·ª£c ch·ªçn t·ª´ dropdown"""
        selected_items = self.gui.device_tree.selection()
        if not selected_items:
            self.gui.log_status("‚ö†Ô∏è Vui l√≤ng ch·ªçn √≠t nh·∫•t 1 device tr∆∞·ªõc!")
            return
        
        # Map dropdown selection to feature key (updated for compact format)
        feature_mapping = {
            "‚öîÔ∏è Rally": "rally",
            "üõí Buy Meat": "buy_meat", 
            "üéØ War": "war_no_general",
            "üëπ Attack Boss": "attack_boss",
            "üì¶ Open Items": "open_items",
            "‚öîÔ∏è Advanced Rally": "advanced_rally",
            "üéØ Advanced War": "advanced_war",
            # Keep old format for backward compatibility
            "‚öîÔ∏è Auto Rally": "rally",
            "üõí Auto Buy Meat": "buy_meat", 
            "üéØ Auto War (No General)": "war_no_general",
            "üëπ Auto Attack Boss": "attack_boss",
            "üì¶ Auto Open Items": "open_items"
        }
        
        selected_feature = self.gui.feature_var.get()
        feature_key = feature_mapping.get(selected_feature)
        
        # Debug: Log selected feature
        self.gui.log_status(f"üîç Selected feature: '{selected_feature}'")
        self.gui.log_status(f"üîç Available mappings: {list(feature_mapping.keys())}")
        
        if not feature_key:
            self.gui.log_status("‚ùå Vui l√≤ng ch·ªçn feature t·ª´ dropdown!")
            self.gui.log_status(f"‚ùå Kh√¥ng t√¨m th·∫•y mapping cho: '{selected_feature}'")
            return
        
        added_count = 0
        for device_item in selected_items:
            if self.add_device_to_feature(device_item, feature_key, show_log=False):
                added_count += 1
        
        if added_count > 0:
            self.gui.log_status(f"‚úÖ ƒê√£ th√™m {added_count} device(s) v√†o {selected_feature}")
        else:
            self.gui.log_status("‚ö†Ô∏è Kh√¥ng c√≥ device n√†o ƒë∆∞·ª£c th√™m (c√≥ th·ªÉ ƒë√£ t·ªìn t·∫°i trong feature)")
    
    def add_selected_to_feature(self, feature_key):
        """Th√™m t·∫•t c·∫£ devices ƒë√£ ch·ªçn v√†o feature c·ª• th·ªÉ"""
        selected_items = self.gui.device_tree.selection()
        if not selected_items:
            self.gui.log_status("‚ö†Ô∏è Vui l√≤ng ch·ªçn √≠t nh·∫•t 1 device tr∆∞·ªõc!")
            return
        
        added_count = 0
        for device_item in selected_items:
            if self.add_device_to_feature(device_item, feature_key, show_log=False):
                added_count += 1
        
        if added_count > 0:
            self.gui.log_status(f"‚úÖ ƒê√£ th√™m {added_count} device(s) v√†o {feature_key}")
        else:
            self.gui.log_status("‚ö†Ô∏è Kh√¥ng c√≥ device n√†o ƒë∆∞·ª£c th√™m (c√≥ th·ªÉ ƒë√£ t·ªìn t·∫°i trong feature)")
